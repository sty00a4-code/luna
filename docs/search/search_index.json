{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Luna A light weight scripting language for quick and easy coding. It is very easy to embed in Rust programs with the luna-lib crate. Documentation Home Getting Started: Installation Environment Tutorial: Grammar Statements Expressions Variables Functions Standard Modules: Globals Type Modules: Int Module Float Module Bool Module Char Module String Module Vector Module Object Module Math IO FS Env Net OS Typed","title":"Home"},{"location":"#luna","text":"A light weight scripting language for quick and easy coding. It is very easy to embed in Rust programs with the luna-lib crate.","title":"Luna"},{"location":"#documentation","text":"Home Getting Started: Installation Environment Tutorial: Grammar Statements Expressions Variables Functions Standard Modules: Globals Type Modules: Int Module Float Module Bool Module Char Module String Module Vector Module Object Module Math IO FS Env Net OS Typed","title":"Documentation"},{"location":"getting_started/environment/","text":"Environment If you want to add additional functionality onto Luna you can use the LUNA_PATH environment variable that the Luna interpreter is using to locate modules if not found in the current directory. The environment variable should look something like this: ~/.luna or if you want it for all users /.luna . Of course you first have to create that directory.","title":"Environment"},{"location":"getting_started/environment/#environment","text":"If you want to add additional functionality onto Luna you can use the LUNA_PATH environment variable that the Luna interpreter is using to locate modules if not found in the current directory. The environment variable should look something like this: ~/.luna or if you want it for all users /.luna . Of course you first have to create that directory.","title":"Environment"},{"location":"getting_started/installation/","text":"Installation To install Luna you have to have cargo installed on your system as well as rustc and build the project yourself. Linux Clone the repository gh repo clone sty00a4-code/luna or download the source code In the new folder, build the code with cargo bundle --release (gives you the path target/release/bundle/deb/luna_{VERSION}_{CPU}.deb ) sudo dpkg -i target/release/bundle/deb/luna_{VERSION}_{CPU}.deb Windows not yet supported due to cargo bundle not working properly on windows systems. it's best to use the Ubuntu subsystem for Windows and install it on there with the Linux instructions.","title":"Installation"},{"location":"getting_started/installation/#installation","text":"To install Luna you have to have cargo installed on your system as well as rustc and build the project yourself.","title":"Installation"},{"location":"getting_started/installation/#linux","text":"Clone the repository gh repo clone sty00a4-code/luna or download the source code In the new folder, build the code with cargo bundle --release (gives you the path target/release/bundle/deb/luna_{VERSION}_{CPU}.deb ) sudo dpkg -i target/release/bundle/deb/luna_{VERSION}_{CPU}.deb","title":"Linux"},{"location":"getting_started/installation/#windows","text":"not yet supported due to cargo bundle not working properly on windows systems. it's best to use the Ubuntu subsystem for Windows and install it on there with the Linux instructions.","title":"Windows"},{"location":"standard_modules/env/","text":"","title":"Env"},{"location":"standard_modules/fs/","text":"","title":"FS"},{"location":"standard_modules/globals/","text":"","title":"Globals"},{"location":"standard_modules/io/","text":"","title":"IO"},{"location":"standard_modules/math/","text":"","title":"Math"},{"location":"standard_modules/net/","text":"","title":"Net"},{"location":"standard_modules/os/","text":"","title":"OS"},{"location":"standard_modules/typed/","text":"","title":"Typed"},{"location":"standard_modules/type_modules/bool_module/","text":"","title":"Bool Module"},{"location":"standard_modules/type_modules/char_module/","text":"","title":"Char Module"},{"location":"standard_modules/type_modules/float_module/","text":"","title":"Float Module"},{"location":"standard_modules/type_modules/int_module/","text":"","title":"Int Module"},{"location":"standard_modules/type_modules/object_module/","text":"","title":"Object Module"},{"location":"standard_modules/type_modules/string_module/","text":"","title":"String Module"},{"location":"standard_modules/type_modules/vector_module/","text":"","title":"Vector Module"},{"location":"tutorial/expressions/","text":"Expressions An expression has a lot of variants like binary or unary expressions, calls or just be an Atom Atom An Atom is the smallest possible expression, just being one value or a Path . Values All of the tokens that are atomic like null , int , float , etc. are valid Atoms. Examples: 1 , null , true , \"hello there\" Sub-Expression Of course an Atom can also be another Expression Examples: (a + b) , ((a + b) * c) , (1) Vector A list of Expressions Examples: [1, 2, 3] , [a + b, \"joe\", false] Object A list of identifier and Expression pairs Examples: { name = \"joe\", age = 25 } If-Expression A conditional expression branch with required if and else-cases. Examples: if age > 18 \"of age\" else \"under age\" Function Definition This is used to define functions with parameters as an expression. Examples: fn (a, b) { return a + b } Path A path is either an identifier or a field/index into another path Examples: a , a.b , a.b.c , a[1]","title":"Expressions"},{"location":"tutorial/expressions/#expressions","text":"An expression has a lot of variants like binary or unary expressions, calls or just be an Atom","title":"Expressions"},{"location":"tutorial/expressions/#atom","text":"An Atom is the smallest possible expression, just being one value or a Path .","title":"Atom"},{"location":"tutorial/expressions/#values","text":"All of the tokens that are atomic like null , int , float , etc. are valid Atoms. Examples: 1 , null , true , \"hello there\"","title":"Values"},{"location":"tutorial/expressions/#sub-expression","text":"Of course an Atom can also be another Expression Examples: (a + b) , ((a + b) * c) , (1)","title":"Sub-Expression"},{"location":"tutorial/expressions/#vector","text":"A list of Expressions Examples: [1, 2, 3] , [a + b, \"joe\", false]","title":"Vector"},{"location":"tutorial/expressions/#object","text":"A list of identifier and Expression pairs Examples: { name = \"joe\", age = 25 }","title":"Object"},{"location":"tutorial/expressions/#if-expression","text":"A conditional expression branch with required if and else-cases. Examples: if age > 18 \"of age\" else \"under age\"","title":"If-Expression"},{"location":"tutorial/expressions/#function-definition","text":"This is used to define functions with parameters as an expression. Examples: fn (a, b) { return a + b }","title":"Function Definition"},{"location":"tutorial/expressions/#path","text":"A path is either an identifier or a field/index into another path Examples: a , a.b , a.b.c , a[1]","title":"Path"},{"location":"tutorial/functions/","text":"","title":"Functions"},{"location":"tutorial/grammar/","text":"Grammar The grammar of Luna is very closue to modern languages like JavaScript and Rust Atomic Tokens The following is a list of atomic tokens and what their regex is: name regex null /null/ ident /[a-zA-Z_]([a-zA-Z_0-9]*)/ int /[0-9]+/ float /[0-9]+\\./ , /[0-9]+\\.[0-9]+/ bool /true/ , /false/ char /'\\.'/ string /\"[^\"]*\"/ Keywords The following is a list of reserved keywords: keyword description let local variable definitions fn function definitions if conditional branches else else conditional branches of if statements while while loops for for loops in iterate over somethin in a for loop statement return return from a call break break out of a loop continue skip to next iteration of a loop null represents the null value true represents the boolean value true false represents the boolean value false Symbols The following is a list of reserved keywords: symbol name = equal , comma . dot : colon ! exclamation ( paran left ) paran right [ bracket left ] bracket right { brace left } brace right + plus - minus * star / slash % percent ^ exponent += plus equal -= minus equal *= star equal /= slash equal %= percent equal ^= exponent equal == equal equal != exclamation equal < less > greater <= less equal >= greater equal & ampersand | pipe Syntax Sugar Luna has the same design philosophy as Lua. What that means is that certain syntax is only another way to write the same thing: fn add(a, b) { return a + b } translates to add = fn(a, b) { return a + b }","title":"Grammar"},{"location":"tutorial/grammar/#grammar","text":"The grammar of Luna is very closue to modern languages like JavaScript and Rust","title":"Grammar"},{"location":"tutorial/grammar/#atomic-tokens","text":"The following is a list of atomic tokens and what their regex is: name regex null /null/ ident /[a-zA-Z_]([a-zA-Z_0-9]*)/ int /[0-9]+/ float /[0-9]+\\./ , /[0-9]+\\.[0-9]+/ bool /true/ , /false/ char /'\\.'/ string /\"[^\"]*\"/","title":"Atomic Tokens"},{"location":"tutorial/grammar/#keywords","text":"The following is a list of reserved keywords: keyword description let local variable definitions fn function definitions if conditional branches else else conditional branches of if statements while while loops for for loops in iterate over somethin in a for loop statement return return from a call break break out of a loop continue skip to next iteration of a loop null represents the null value true represents the boolean value true false represents the boolean value false","title":"Keywords"},{"location":"tutorial/grammar/#symbols","text":"The following is a list of reserved keywords: symbol name = equal , comma . dot : colon ! exclamation ( paran left ) paran right [ bracket left ] bracket right { brace left } brace right + plus - minus * star / slash % percent ^ exponent += plus equal -= minus equal *= star equal /= slash equal %= percent equal ^= exponent equal == equal equal != exclamation equal < less > greater <= less equal >= greater equal & ampersand | pipe","title":"Symbols"},{"location":"tutorial/grammar/#syntax-sugar","text":"Luna has the same design philosophy as Lua. What that means is that certain syntax is only another way to write the same thing: fn add(a, b) { return a + b } translates to add = fn(a, b) { return a + b }","title":"Syntax Sugar"},{"location":"tutorial/statements/","text":"Statements A Luna program is basically a list of statements, called a Chunk . Chunk A list of statements with no seperator Block Just a list of statements like a Chunk , but it requires { at the start and } at the end. Statement A statement has a lot of variants, like let-bindings, function definitions, etc. But it also can as well just be a Block Let Binding This is what you define local variables with. The assignees can be simple identifiers or object/vector destructurings. Examples: let a = 1 , let { name, age } = person , let [first, second, third] = numbers Assign This is how you assign new values to existing variables. The assignees can be simple identifiers or a field/index into an object/vector Examples: a = 2 Assign Operation Written the same way as Assign expect with any of the following assign operators, only one assignee and only one expression: assign operators += -= *= /= ^= %= Examples: a += 1 , b *= 2 Call This is to call functions with arguments. The callee can either be a simple identifier or a field/index of an object/vector. Examples: print(\"Hello, World!\") , self.add(1) Self Call Just like a Call only written with a : followed by an identifier. This calls the function with the first argument being the value before the : . This is used to call objects with themselfs for object-oriented design patterns. Examples: vector:push(1) , person:greet() Function Definition This is used to globally define functions with parameters. Examples: fn add(a, b) { return a + b } Let-Function Definition This is used to locally define functions with parameters in the current scope. Examples: let fn add(a, b) { return a + b } If-Branch Classical if-branch like any other. Has an optional else-case which can either be a block or another if-branch. Examples: if cond { print(\"yay\") } else { print(\"nay\") } , if cond { print(\"yay\") } else if cond2 { print(\"semi-yay\") } While-Loop Classical while-loop like any other. body has to be a block Examples: while a < 10 { a += 1 } For-Loop Python-like for-loop that requires an iterable to be right of the in keyword. Only one variable can be given for each iteration. An iterable can either be an user-object with a next method, an object with the meta variable __next which is a function, or just a function. Examples: for n in [1, 2, 3]:iter() { print(n) } , for key in keys(map) { print(key, map[key]) } Return This is used to return a value to the caller and end execution of the current function. Examples: return a + b , return null Break This is used to break out of any loop. Examples: while true { if a >= 10 { break } } Continue This is used to continue to the next iteration of the loop. Examples: for n in numbers:iter() { if n == 5 { continue } print(n) }","title":"Statements"},{"location":"tutorial/statements/#statements","text":"A Luna program is basically a list of statements, called a Chunk .","title":"Statements"},{"location":"tutorial/statements/#chunk","text":"A list of statements with no seperator","title":"Chunk"},{"location":"tutorial/statements/#block","text":"Just a list of statements like a Chunk , but it requires { at the start and } at the end.","title":"Block"},{"location":"tutorial/statements/#statement","text":"A statement has a lot of variants, like let-bindings, function definitions, etc. But it also can as well just be a Block","title":"Statement"},{"location":"tutorial/statements/#let-binding","text":"This is what you define local variables with. The assignees can be simple identifiers or object/vector destructurings. Examples: let a = 1 , let { name, age } = person , let [first, second, third] = numbers","title":"Let Binding"},{"location":"tutorial/statements/#assign","text":"This is how you assign new values to existing variables. The assignees can be simple identifiers or a field/index into an object/vector Examples: a = 2","title":"Assign"},{"location":"tutorial/statements/#assign-operation","text":"Written the same way as Assign expect with any of the following assign operators, only one assignee and only one expression: assign operators += -= *= /= ^= %= Examples: a += 1 , b *= 2","title":"Assign Operation"},{"location":"tutorial/statements/#call","text":"This is to call functions with arguments. The callee can either be a simple identifier or a field/index of an object/vector. Examples: print(\"Hello, World!\") , self.add(1)","title":"Call"},{"location":"tutorial/statements/#self-call","text":"Just like a Call only written with a : followed by an identifier. This calls the function with the first argument being the value before the : . This is used to call objects with themselfs for object-oriented design patterns. Examples: vector:push(1) , person:greet()","title":"Self Call"},{"location":"tutorial/statements/#function-definition","text":"This is used to globally define functions with parameters. Examples: fn add(a, b) { return a + b }","title":"Function Definition"},{"location":"tutorial/statements/#let-function-definition","text":"This is used to locally define functions with parameters in the current scope. Examples: let fn add(a, b) { return a + b }","title":"Let-Function Definition"},{"location":"tutorial/statements/#if-branch","text":"Classical if-branch like any other. Has an optional else-case which can either be a block or another if-branch. Examples: if cond { print(\"yay\") } else { print(\"nay\") } , if cond { print(\"yay\") } else if cond2 { print(\"semi-yay\") }","title":"If-Branch"},{"location":"tutorial/statements/#while-loop","text":"Classical while-loop like any other. body has to be a block Examples: while a < 10 { a += 1 }","title":"While-Loop"},{"location":"tutorial/statements/#for-loop","text":"Python-like for-loop that requires an iterable to be right of the in keyword. Only one variable can be given for each iteration. An iterable can either be an user-object with a next method, an object with the meta variable __next which is a function, or just a function. Examples: for n in [1, 2, 3]:iter() { print(n) } , for key in keys(map) { print(key, map[key]) }","title":"For-Loop"},{"location":"tutorial/statements/#return","text":"This is used to return a value to the caller and end execution of the current function. Examples: return a + b , return null","title":"Return"},{"location":"tutorial/statements/#break","text":"This is used to break out of any loop. Examples: while true { if a >= 10 { break } }","title":"Break"},{"location":"tutorial/statements/#continue","text":"This is used to continue to the next iteration of the loop. Examples: for n in numbers:iter() { if n == 5 { continue } print(n) }","title":"Continue"},{"location":"tutorial/variables/","text":"Variables Variables in Luna are scoped. let a = 1 { let b = 2 print(a) print(b) } print(a) Here we created two variables a and b . a is scoped to the entire chunk of code, but b on the other hand is only scoped to the two curly braces. This is because we are defining a block with { and } which has it's own scope that ends at the } . Parameters Function parameters are just like local variables, just that they are bound differently. fn add(a, b) { let result = a + b return result } When calling this function with arguments as follows, 1 and 2 will be assigned to a and b for that call: add(1, 2) Globals Variables don't have to be assigned locally to a scope though. The other way is to create variables is globally by just using an assignment statement with no let in front of it. VAR = \"this is a global variables\" No matter where, after this statement has been executed, does the interpreter not have access to that value through that name.","title":"Variables"},{"location":"tutorial/variables/#variables","text":"Variables in Luna are scoped. let a = 1 { let b = 2 print(a) print(b) } print(a) Here we created two variables a and b . a is scoped to the entire chunk of code, but b on the other hand is only scoped to the two curly braces. This is because we are defining a block with { and } which has it's own scope that ends at the } .","title":"Variables"},{"location":"tutorial/variables/#parameters","text":"Function parameters are just like local variables, just that they are bound differently. fn add(a, b) { let result = a + b return result } When calling this function with arguments as follows, 1 and 2 will be assigned to a and b for that call: add(1, 2)","title":"Parameters"},{"location":"tutorial/variables/#globals","text":"Variables don't have to be assigned locally to a scope though. The other way is to create variables is globally by just using an assignment statement with no let in front of it. VAR = \"this is a global variables\" No matter where, after this statement has been executed, does the interpreter not have access to that value through that name.","title":"Globals"}]}